<<<<<<< Updated upstream
# Set up the window sizes for the rolling and expanding windows
rolling_window_size <- bubu
expanding_window_size <- nrow(data) - rolling_window_size
# Set up the initial model using the first window of data
#model <- Arima(data[1:rolling_window_size, "ts_real_inf_3"], order = c(1,1,1), xreg = data[1:rolling_window_size, "ext_regressors"])
# Set up empty vectors to store the forecasts and actuals
rolling_forecasts <- numeric()
rolling_actuals <- numeric()
expanding_forecasts <- numeric()
expanding_actuals <- numeric()
window_size <- rolling_window_size  # Length of the rolling window
n_ahead <- 1
library(forecast)
# Assuming ts_real_inf_3 and ext_regressors are time series objects with the same frequency and date range
start_date <- start(ts_real_inf)
end_date <- end(ts_real_inf)
n_iterations <- length(ts_real_inf) - window_size - n_ahead
forecasts_rw <- list()
for (i in 1:n_iterations) {
debug_print(i/n_iterations)
start_window <- start_date + (i - 1) * c(0, 1)
end_window <- start_window + c(0, window_size - 1)
ts_window <- window(ts_real_inf, start = start_window, end = end_window)
ext_regressors_window <- window(ext_regressors, start = start_window, end = end_window)
tryCatch({
model <- Arima(ts_window, order = c(ar, dif, ma), xreg = ext_regressors_window)
start_forecast <- end_window + c(0, 1)
end_forecast <- start_forecast + c(0, n_ahead - 1)
ext_regressors_forecast <- window(ext_regressors, start = start_forecast, end = end_forecast)
forecast_result <- forecast::forecast(model, h = n_ahead, xreg = ext_regressors_forecast)
forecasts_rw[[i]] <- forecast_result
}, error = function(e) {
cat("Error at iteration", i, ":", e$message, "\n")
forecasts_rw[[i]] <- "TVOJE"
})
}
point_estimates_rw <- do.call(c, lapply(forecasts_rw, function(x) x$mean))
# bodiky
{
# Print the point estimates
debug_print(point_estimates_rw)
# Create a new time series object with the forecasted values and their respective time indexes
prec <- c(window_size )
start_forecast_all <- start_date + c(0 , window_size)
end_forecast_all <- end_date
ts_forecast <- ts(point_estimates_rw, start = start_forecast_all, end = end_forecast_all, frequency = frequency(ts_real_inf))
# Plot the actual and forecasted values together
#ts.plot(ts_real_inf_3, ts_forecast, col = c("black", "red"), lty = c(1, 1), main = "Actual vs. Forecasted Values", xlab = "Time", ylab = "Value")
#legend("topleft", legend = c("Actual", "Forecast"), col = c("black", "red"), lty = c(1, 1), bty = "n")
# Extract the actual values for which we have forecasts
actual_values <- window(ts_real_inf, start = start_forecast_all, end = end_forecast_all)
# Calculate quality measures
mae <- mean(abs(actual_values - point_estimates_rw))
mse <- mean((actual_values - point_estimates_rw)^2)
rmse <- sqrt(mse)
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu,"ext", "rw", mae, mse, rmse))
start_date <- start(ts_real_inf)
end_date <- end(ts_real_inf)
n_iterations <- length(ts_real_inf) - window_size - n_ahead
forecasts_rw_bez <- list()
for (i in 1:n_iterations) {
debug_print(i/n_iterations)
start_window <- start_date + (i - 1) * c(0, 1)
end_window <- start_window + c(0, window_size - 1)
ts_window <- window(ts_real_inf, start = start_window, end = end_window)
ext_regressors_window <- window(ext_regressors, start = start_window, end = end_window)
tryCatch({
model <- Arima(ts_window, order = c(ar_bez, dif_bez, ma_bez))
start_forecast <- end_window + c(0, 1)
end_forecast <- start_forecast + c(0, n_ahead - 1)
ext_regressors_forecast <- window(ext_regressors, start = start_forecast, end = end_forecast)
forecast_result <- forecast::forecast(model, h = n_ahead, xreg = ext_regressors_forecast)
forecasts_rw_bez[[i]] <- forecast_result
}, error = function(e) {
cat("Error at iteration", i, ":", e$message, "\n")
forecasts_rw_bez[[i]] <- "TVOJE"
})
}
point_estimates_rw_bez <- do.call(c, lapply(forecasts_rw_bez, function(x) x$mean))
# bodiky
{
# Print the point estimates
debug_print(point_estimates_rw_bez)
# Create a new time series object with the forecasted values and their respective time indexes
prec <- c(window_size )
start_forecast_all <- start_date + c(0 , window_size)
end_forecast_all <- end_date
ts_forecast <- ts(point_estimates_rw_bez, start = start_forecast_all, end = end_forecast_all, frequency = frequency(ts_real_inf))
# Plot the actual and forecasted values together
#ts.plot(ts_real_inf_3, ts_forecast, col = c("black", "red"), lty = c(1, 1), main = "Actual vs. Forecasted Values", xlab = "Time", ylab = "Value")
#legend("topleft", legend = c("Actual", "Forecast"), col = c("black", "red"), lty = c(1, 1), bty = "n")
# Extract the actual values for which we have forecasts
actual_values <- window(ts_real_inf, start = start_forecast_all, end = end_forecast_all)
# Calculate quality measures
mae <- mean(abs(actual_values - point_estimates_rw_bez))
mse <- mean((actual_values - point_estimates_rw_bez)^2)
rmse <- sqrt(mse)
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu,"bez", "rw", mae, mse, rmse))
# Expanding window forecast
n <- length(ts_real_inf)
start_forecast <- rolling_window_size
forecasts <- ts(numeric(n - start_forecast + 1), start = start(ts_real_inf)[1] + (start_forecast - 1) / frequency(ts_real_inf), frequency = frequency(ts_real_inf))
for (t in start_forecast:n) {
# Fit the ARIMA model with the external regressor on the expanding window
model <- Arima(ts_real_inf[1:(t - 1)], order = c(ar, dif, ma), xreg = ext_regressors[1:(t - 1)])
# One-step ahead forecast
forecast <- predict(model, n.ahead = 1, newxreg = ext_regressors[t])
# Save the forecast
forecasts[t - start_forecast + 1] <- forecast$pred
}
# bodiky
{
# Print the forecasts
debug_print(forecasts)
lines(forecasts, col = "blue")
# Calculate the errors
errors <- forecasts - ts_real_inf[start_forecast:n]
# Calculate MAE
mae <- mean(abs(errors))
# Calculate MSE
mse <- mean(errors^2)
# Calculate RMSE
rmse <- sqrt(mse)
# Print the results
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu,"ext", "ew", mae, mse, rmse))
for (t in start_forecast:n) {
# Fit the ARIMA model with the external regressor on the expanding window
model <- Arima(ts_real_inf[1:(t - 1)], order = c(ar_bez, dif_bez, ma_bez))
# One-step ahead forecast
forecast <- predict(model, n.ahead = 1)
# Save the forecast
forecasts[t - start_forecast + 1] <- forecast$pred
}
# bodiky
{
# Print the forecasts
debug_print(forecasts)
lines(forecasts, col = "blue")
# Calculate the errors
errors <- forecasts - ts_real_inf[start_forecast:n]
# Calculate MAE
mae <- mean(abs(errors))
# Calculate MSE
mse <- mean(errors^2)
# Calculate RMSE
rmse <- sqrt(mse)
# Print the results
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
#################################################### Rolling and expanding window forecasts bez regresoru
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu, "bez", "ew", mae, mse, rmse))
}
#sejvuju env
tabulka_nej_model <- as.data.frame(tabulka_nej_model)
tabulka_nej_model_z <- tabulka_nej_model
tabulka_nej_model <- tabulka_nej_model[-1,]
colnames(tabulka_nej_model) <- as.character(uga)
tabulka_nej_model
=======
>>>>>>> Stashed changes
tabulka_nej_model$iterace <- as.numeric(tabulka_nej_model$iterace)
tabulka_nej_model$mae <- as.numeric(tabulka_nej_model$mae)
tabulka_nej_model$mse <- as.numeric(tabulka_nej_model$mse)
tabulka_nej_model$rmse <- as.numeric(tabulka_nej_model$rmse)
tabulka_nej_model
meritka <- c("mae","mse", "rmse")
par(mfrow = c(2, 2))
for (model in unique(tabulka_nej_model$ext)) {
for (predpoved in unique(tabulka_nej_model$rw)) {
data_graf <- tabulka_nej_model %>% filter(ext == model)
data_graf <- data_graf %>% filter(rw == predpoved)
if (model == "ext") {
nazev_grafu_ext <- "External regressor"
} else {
nazev_grafu_ext <- "Benchmark model"
}
if (predpoved == "rw") {
nazev_grafu_rw <- "Rolling window forecast"
} else {
nazev_grafu_rw <- "Expanding window forecast"
}
matplot(data_graf$iterace, data_graf[, meritka], type = "l", ylim = c(0.0,0.9),
xlab = "(Starting) Window length", ylab = "Value", main = c(paste(nazev_grafu_rw, " - ", nazev_grafu_ext)))
legend("topleft", legend = colnames(data_graf[, meritka]), col = 1:3, lty = 1, cex = 0.8)
}
}
line_types <- c(1, 1, 1, 2, 2, 2)
colores <- c("#3399FF", "#33CC66", "#FF0000", "#4DA6FF", "#66CC99", "#FF6666")#3399FF #33CC66
par(mfrow = c(1, 1))
for (predpoved in unique(tabulka_nej_model$rw)) {
if (predpoved == "rw") {
nazev_grafu_rw <- "Rolling window forecast"
} else {
nazev_grafu_rw <- "Expanding window forecast"
}
data_graf <- tabulka_nej_model %>% filter(rw == predpoved)
jmena_sloupcu <- colnames(data_graf)
print(predpoved)
data_graf <- cbind(data_graf %>% filter(ext == "ext"), data_graf %>% filter(ext == "bez"))
print(data_graf)
colnames(data_graf)[7:12] <- c("v1", "v2","v3", "mae - benchmark", "mse - benchmark", "rmse - benchmark")
meritka <- c("mae","mse", "rmse", "mae - benchmark", "mse - benchmark", "rmse - benchmark")
if(predpoved == "rw"){
osa_x <- "Window length"
} else {
osa_x <- "Starting window length"
}
matplot(data_graf$iterace, data_graf[, meritka], type = "l", lty = line_types, ylim = c(0.0,0.9),
xlab = osa_x, ylab = "Value", col = colores, main = nazev_grafu_rw)
# Add a legend
legend("top", legend = colnames(data_graf[, meritka]), col = colores, lty = line_types, cex = 1)
}
bench <- FALSE
if(bench == TRUE){
ar_bez <- ar
dif_bez <- dif
ma_bez <- ma
} else {
ar_bez <- modelos$arma[1]
dif_bez <- modelos$arma[6]
ma_bez <- modelos$arma[2]
}
end   <- c(2023, 2)
regresor <- ts(data = gt_dss[,"cena.nafty"], start = c(2004, 1), end = end, frequency = 12)
regresor <- regresor / mean(regresor) * mean(regresor)
ext_regressor <- as.vector(regresor)
ext_regressor <- lag(ext_regressor, posun)
ext_regressors <- ts(ext_regressor, start = c(start[1], (start[2])), frequency = 12)
arima_model <- try(forecast::Arima(ts_real_inf, order = c(ar,dif,ma), xreg = ext_regressors))
arima_model$fitted
# Combine the data into a single data frame
data <- data.frame(ts_real_inf, ext_regressors)
uga <-  c("iterace", "ext", "rw", "mae", "mse", "rmse")
tabulka_nej_model <- matrix( nrow = 1, ncol = length(uga))
colnames(tabulka_nej_model) <- as.character(uga)
# sejvni env - bubu verze
#######################################################################################################################################################
for (bubu in 72:200) {
print(bubu)
# Set up the window sizes for the rolling and expanding windows
rolling_window_size <- bubu
expanding_window_size <- nrow(data) - rolling_window_size
# Set up the initial model using the first window of data
#model <- Arima(data[1:rolling_window_size, "ts_real_inf_3"], order = c(1,1,1), xreg = data[1:rolling_window_size, "ext_regressors"])
# Set up empty vectors to store the forecasts and actuals
rolling_forecasts <- numeric()
rolling_actuals <- numeric()
expanding_forecasts <- numeric()
expanding_actuals <- numeric()
window_size <- rolling_window_size  # Length of the rolling window
n_ahead <- 1
library(forecast)
# Assuming ts_real_inf_3 and ext_regressors are time series objects with the same frequency and date range
start_date <- start(ts_real_inf)
end_date <- end(ts_real_inf)
n_iterations <- length(ts_real_inf) - window_size - n_ahead
forecasts_rw <- list()
for (i in 1:n_iterations) {
debug_print(i/n_iterations)
start_window <- start_date + (i - 1) * c(0, 1)
end_window <- start_window + c(0, window_size - 1)
ts_window <- window(ts_real_inf, start = start_window, end = end_window)
ext_regressors_window <- window(ext_regressors, start = start_window, end = end_window)
tryCatch({
model <- Arima(ts_window, order = c(ar, dif, ma), xreg = ext_regressors_window)
start_forecast <- end_window + c(0, 1)
end_forecast <- start_forecast + c(0, n_ahead - 1)
ext_regressors_forecast <- window(ext_regressors, start = start_forecast, end = end_forecast)
forecast_result <- forecast::forecast(model, h = n_ahead, xreg = ext_regressors_forecast)
forecasts_rw[[i]] <- forecast_result
}, error = function(e) {
cat("Error at iteration", i, ":", e$message, "\n")
forecasts_rw[[i]] <- "TVOJE"
})
}
point_estimates_rw <- do.call(c, lapply(forecasts_rw, function(x) x$mean))
# bodiky
{
# Print the point estimates
debug_print(point_estimates_rw)
# Create a new time series object with the forecasted values and their respective time indexes
prec <- c(window_size )
start_forecast_all <- start_date + c(0 , window_size)
end_forecast_all <- end_date
ts_forecast <- ts(point_estimates_rw, start = start_forecast_all, end = end_forecast_all, frequency = frequency(ts_real_inf))
# Plot the actual and forecasted values together
#ts.plot(ts_real_inf_3, ts_forecast, col = c("black", "red"), lty = c(1, 1), main = "Actual vs. Forecasted Values", xlab = "Time", ylab = "Value")
#legend("topleft", legend = c("Actual", "Forecast"), col = c("black", "red"), lty = c(1, 1), bty = "n")
# Extract the actual values for which we have forecasts
actual_values <- window(ts_real_inf, start = start_forecast_all, end = end_forecast_all)
# Calculate quality measures
mae <- mean(abs(actual_values - point_estimates_rw))
mse <- mean((actual_values - point_estimates_rw)^2)
rmse <- sqrt(mse)
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu,"ext", "rw", mae, mse, rmse))
start_date <- start(ts_real_inf)
end_date <- end(ts_real_inf)
n_iterations <- length(ts_real_inf) - window_size - n_ahead
forecasts_rw_bez <- list()
for (i in 1:n_iterations) {
debug_print(i/n_iterations)
start_window <- start_date + (i - 1) * c(0, 1)
end_window <- start_window + c(0, window_size - 1)
ts_window <- window(ts_real_inf, start = start_window, end = end_window)
ext_regressors_window <- window(ext_regressors, start = start_window, end = end_window)
tryCatch({
model <- Arima(ts_window, order = c(ar_bez, dif_bez, ma_bez))
start_forecast <- end_window + c(0, 1)
end_forecast <- start_forecast + c(0, n_ahead - 1)
ext_regressors_forecast <- window(ext_regressors, start = start_forecast, end = end_forecast)
forecast_result <- forecast::forecast(model, h = n_ahead, xreg = ext_regressors_forecast)
forecasts_rw_bez[[i]] <- forecast_result
}, error = function(e) {
cat("Error at iteration", i, ":", e$message, "\n")
forecasts_rw_bez[[i]] <- "TVOJE"
})
}
point_estimates_rw_bez <- do.call(c, lapply(forecasts_rw_bez, function(x) x$mean))
# bodiky
{
# Print the point estimates
debug_print(point_estimates_rw_bez)
# Create a new time series object with the forecasted values and their respective time indexes
prec <- c(window_size )
start_forecast_all <- start_date + c(0 , window_size)
end_forecast_all <- end_date
ts_forecast <- ts(point_estimates_rw_bez, start = start_forecast_all, end = end_forecast_all, frequency = frequency(ts_real_inf))
# Plot the actual and forecasted values together
#ts.plot(ts_real_inf_3, ts_forecast, col = c("black", "red"), lty = c(1, 1), main = "Actual vs. Forecasted Values", xlab = "Time", ylab = "Value")
#legend("topleft", legend = c("Actual", "Forecast"), col = c("black", "red"), lty = c(1, 1), bty = "n")
# Extract the actual values for which we have forecasts
actual_values <- window(ts_real_inf, start = start_forecast_all, end = end_forecast_all)
# Calculate quality measures
mae <- mean(abs(actual_values - point_estimates_rw_bez))
mse <- mean((actual_values - point_estimates_rw_bez)^2)
rmse <- sqrt(mse)
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu,"bez", "rw", mae, mse, rmse))
# Expanding window forecast
n <- length(ts_real_inf)
start_forecast <- rolling_window_size
forecasts <- ts(numeric(n - start_forecast + 1), start = start(ts_real_inf)[1] + (start_forecast - 1) / frequency(ts_real_inf), frequency = frequency(ts_real_inf))
for (t in start_forecast:n) {
# Fit the ARIMA model with the external regressor on the expanding window
model <- Arima(ts_real_inf[1:(t - 1)], order = c(ar, dif, ma), xreg = ext_regressors[1:(t - 1)])
# One-step ahead forecast
forecast <- predict(model, n.ahead = 1, newxreg = ext_regressors[t])
# Save the forecast
forecasts[t - start_forecast + 1] <- forecast$pred
}
# bodiky
{
# Print the forecasts
debug_print(forecasts)
lines(forecasts, col = "blue")
# Calculate the errors
errors <- forecasts - ts_real_inf[start_forecast:n]
# Calculate MAE
mae <- mean(abs(errors))
# Calculate MSE
mse <- mean(errors^2)
# Calculate RMSE
rmse <- sqrt(mse)
# Print the results
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu,"ext", "ew", mae, mse, rmse))
for (t in start_forecast:n) {
# Fit the ARIMA model with the external regressor on the expanding window
model <- Arima(ts_real_inf[1:(t - 1)], order = c(ar_bez, dif_bez, ma_bez))
# One-step ahead forecast
forecast <- predict(model, n.ahead = 1)
# Save the forecast
forecasts[t - start_forecast + 1] <- forecast$pred
}
# bodiky
{
# Print the forecasts
debug_print(forecasts)
lines(forecasts, col = "blue")
# Calculate the errors
errors <- forecasts - ts_real_inf[start_forecast:n]
# Calculate MAE
mae <- mean(abs(errors))
# Calculate MSE
mse <- mean(errors^2)
# Calculate RMSE
rmse <- sqrt(mse)
# Print the results
cat("Mean Absolute Error (MAE):", mae, "\n")
cat("Mean Squared Error (MSE):", mse, "\n")
cat("Root Mean Squared Error (RMSE):", rmse, "\n")
}
#################################################### Rolling and expanding window forecasts bez regresoru
tabulka_nej_model <- rbind(tabulka_nej_model, c(bubu, "bez", "ew", mae, mse, rmse))
}
#sejvuju env
tabulka_nej_model <- as.data.frame(tabulka_nej_model)
tabulka_nej_model_z <- tabulka_nej_model
tabulka_nej_model <- tabulka_nej_model[-1,]
colnames(tabulka_nej_model) <- as.character(uga)
tabulka_nej_model
tabulka_nej_model$iterace <- as.numeric(tabulka_nej_model$iterace)
tabulka_nej_model$mae <- as.numeric(tabulka_nej_model$mae)
tabulka_nej_model$mse <- as.numeric(tabulka_nej_model$mse)
tabulka_nej_model$rmse <- as.numeric(tabulka_nej_model$rmse)
tabulka_nej_model
meritka <- c("mae","mse", "rmse")
par(mfrow = c(2, 2))
for (model in unique(tabulka_nej_model$ext)) {
for (predpoved in unique(tabulka_nej_model$rw)) {
data_graf <- tabulka_nej_model %>% filter(ext == model)
data_graf <- data_graf %>% filter(rw == predpoved)
if (model == "ext") {
nazev_grafu_ext <- "External regressor"
} else {
nazev_grafu_ext <- "Benchmark model"
}
if (predpoved == "rw") {
nazev_grafu_rw <- "Rolling window forecast"
} else {
nazev_grafu_rw <- "Expanding window forecast"
}
matplot(data_graf$iterace, data_graf[, meritka], type = "l", ylim = c(0.0,0.9),
xlab = "(Starting) Window length", ylab = "Value", main = c(paste(nazev_grafu_rw, " - ", nazev_grafu_ext)))
legend("topleft", legend = colnames(data_graf[, meritka]), col = 1:3, lty = 1, cex = 0.8)
}
}
line_types <- c(1, 1, 1, 2, 2, 2)
colores <- c("#3399FF", "#33CC66", "#FF0000", "#4DA6FF", "#66CC99", "#FF6666")#3399FF #33CC66
par(mfrow = c(1, 1))
for (predpoved in unique(tabulka_nej_model$rw)) {
if (predpoved == "rw") {
nazev_grafu_rw <- "Rolling window forecast"
} else {
nazev_grafu_rw <- "Expanding window forecast"
}
data_graf <- tabulka_nej_model %>% filter(rw == predpoved)
jmena_sloupcu <- colnames(data_graf)
print(predpoved)
data_graf <- cbind(data_graf %>% filter(ext == "ext"), data_graf %>% filter(ext == "bez"))
print(data_graf)
colnames(data_graf)[7:12] <- c("v1", "v2","v3", "mae - benchmark", "mse - benchmark", "rmse - benchmark")
meritka <- c("mae","mse", "rmse", "mae - benchmark", "mse - benchmark", "rmse - benchmark")
if(predpoved == "rw"){
osa_x <- "Window length"
} else {
osa_x <- "Starting window length"
}
matplot(data_graf$iterace, data_graf[, meritka], type = "l", lty = line_types, ylim = c(0.0,0.9),
xlab = osa_x, ylab = "Value", col = colores, main = nazev_grafu_rw)
# Add a legend
legend("top", legend = colnames(data_graf[, meritka]), col = colores, lty = line_types, cex = 1)
}
for (predpoved in unique(tabulka_nej_model$rw)) {
if (predpoved == "rw") {
nazev_grafu_rw <- "Rolling window forecast"
} else {
nazev_grafu_rw <- "Expanding window forecast"
}
data_graf <- tabulka_nej_model %>% filter(rw == predpoved)
jmena_sloupcu <- colnames(data_graf)
data_graf <- cbind(data_graf %>% filter(ext == "ext"), data_graf %>% filter(ext == "bez"))
testy <- data_graf[,c(1,4,5,6,10,11,12)]
soucet_m <- testy$mae + testy$mse + testy$rmse
soucet_b <- testy$mae.1 + testy$mse.1 + testy$rmse.1
my_vector <- soucet_m
smallest_values <- sort(my_vector)[1:3]
# Get the indices of the smallest values
indices <- which(my_vector %in% smallest_values)
print(predpoved)
print("3 nejlepsi settingy okna")
print(testy[indices,"iterace"])
print("jak casto nizsi? (%)")
print(sum(soucet_m < soucet_b)/length(soucet_b))
print("parove modely")
alternativa <- c("less")
t_mae <- t.test(testy$mae ,testy$mae.1 , alternative = alternativa, paired = TRUE)
print(t_mae)
t_mse <- t.test(testy$mse ,testy$mse.1 , alternative = alternativa, paired = TRUE)
print(t_mse)
t_rmse <- t.test(testy$rmse ,testy$rmse.1 , alternative = alternativa, paired = TRUE)
print(t_rmse)
print("NEparove modely")
t_mae <- t.test(testy$mae ,testy$mae.1 , alternative = alternativa)
print(t_mae)
t_mse <- t.test(testy$mse ,testy$mse.1 , alternative = alternativa)
print(t_mse)
t_rmse <- t.test(testy$rmse ,testy$rmse.1 , alternative = alternativa)
print(t_rmse)
}
